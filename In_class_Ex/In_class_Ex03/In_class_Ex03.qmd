---
title: "Spatial Interaction Models"
author: "Wan Kee"
date: "21 November 2023"
date modified: "21 November 2023"
format: html
execute: 
  echo: true
  eval: true
  warning: false
editor: source
---

# 1.1 Overview

**Spatial interaction model** is a mathematical model that predicts the movement of people between origins and destinations by examining the distance between them. It is based on (1) their **spatial separation**; (2) their **complementarity**; and (3) other **intervening opportunities** or spatial structural elements serve to augment or diminish the expected flow.

(1) **Complementarity** is an indicator of the suitability of the particular pair of places for the movement 

(2) Interactions may be diverted to **intervening opportunities** with considerations on the relative location of other interacting agents

(3) **Transferability** is measured by cost or time involved in the interaction, and is often represented by a distance-decay function that shows diminishing interaction as distance increases.

Notes diagonals of distance matrix will be zero.

# 1.2 Load packages

`sf` and `sp` performs geospatial data import, integration, processing and transformation.
`DT` enables R data objects (matrices or data frames) to be displayed as tables on HTML pages.
`tidyverse` performs data import, integration, wrangling and visualisation. 
`tmap` creates thematic maps. 
`stplanr`analyses OD matrix.
`reshape2` restructuresa nd aggregates data.

```{r}
pacman::p_load(tmap, sf, sp, DT, stplanr, tidyverse, reshape2)
```

# 1.3 Import data

:::panel-tabset

## Passenger Volume

`odbus` is an **aspatial** dataset containing the number of trips by weekdays and weekends from origin to destination bus stops. It reflects the passenger trip traffic and the most recent dataset from **September 2023** will be used. 

The output indicates **5,714,196 records** and 7 fields. The bus stop codes are converted into factor for data handling.

Source: LTA DataMall ([Postman URL](http://datamall2.mytransport.sg/ltaodataservice/PV/ODBus))

```{r}
od_data = read_rds("data/rds/od_data.rds")
```

## Subzone

`mpsz` is a **geospatial** dataset from the Master Plan 2019, a forward looking guiding plan for Singapore's development in the medium term over the next 10 to 15 years published in **2019**. Note this `mpsz` differs from that in previous chapter, [Data Wrangling](https://cosmic-kitten.netlify.app/hands_on_ex/hands_on_ex01/hands_on_ex01).

The output indicates that the geospatial objects are **multipolygon** features. There are **332 features** and 6 fields. It is in **WGS84** projected coordinates system with **XY** dimension.

```{r}
mpsz = read_rds("data/rds/mpsz.rds")
```

```{r}
print(class(mpsz))
```

## Population

`pop` is an **aspatial** dataset of Singapore residents grouped by planning area or subzone, age group, sex and floor area of residence. The data period is from **June 2011 onwards**. From June 2011 to 2019, the planning areas refer to areas demarcated in the Master Plan 2014, and from June 2020 onwards will be Master Plan 2019.

The output indicates **738,492 records** and 7 fields to illustrate the population distribution by planning area (PA), subzone (SZ), age group (AG), residence floor area (FA), resident count (Pop).

Source: Department of Statistics ([Link](https://www.singstat.gov.sg/-/media/files/find_data/population/statistical_tables/respopagesexfa2011to2020.ashx))

```{r}
pop <- read_csv("data/aspatial/pop.csv")
glimpse(pop)
```

:::

# 1.4 Calibrate Spatial Interaction Model

In spatial interaction, a distance matrix is a table that shows the distance between pairs of locations.
two ways to compute the required distance matrix:
1. sf 
2. sp

We will calibrate SIM to determine factors affecting the public bus passenger flows during the morning peak in Singapore.

## Step 1: Convert from sf data table to spatial polygons data frame

`as()` convert `mpsz` from sf tibble data frame to **spatial polygons** data frame of sp object using `sp`.

```{r}
mpsz_sp <- as(mpsz, "Spatial")
print(class(mpsz_sp))
```
```{r}
head(mpsz_sp, n=5)
```

## Step 2: Compute the distance matrix

`spDists()` of sp package will be used to compute the **Euclidean distance** between the **centroids** of the planning subzones. The output is a matrix object class where the column and row headers are not labeled with the planning subzone codes and the diagonals are zero. There are 332 features, hence 332 points, we will limit to 5 columns and 5 rows.

```{r}
dist <- spDists(mpsz_sp, longlat = FALSE)
head(dist, n = c(5, 5))
```
mpsz_sp_selected <- mpsz_sp %>% select(mpsz\@data\$SUBZONE)

sp: no need

## Step 3: Label the column and row headers of the distance matrix

We will obtain the planning subzone codes from `SUBZONE_C` and create a list of planning subzone codes.

```{r}
sz_names <- mpsz$SUBZONE_C
glimpse(sz_names)
```

`paste0` concatenates vectors after converting to characters and attach the planning subzone codes to the row and column headers of the distance matrix.

```{r}
colnames(dist) <- paste0(sz_names)
rownames(dist) <- paste0(sz_names)
glimpse(dist)
```

## Step 4: Pivot the distance value

`melt()` from `reshape2` convert object into molten dataframe. We will pivot the distance matrix into a long table by using the row and column subzone codes 

NEVER SORT THE DATA; SEQUENCE IS IMPT

```{r}
distPair <- melt(dist) %>% 
  rename(dist = value)
head(distPair, 5)
```

## Step 5: Revise intra-zonal distances with a constant value

Travelling to and fro the same bus stop do not generate any distance travelled and do not reflect real world scenarios. To estimate a pseudo value for intra-zonal distance, we will understand the minimumn, maximum, mean of the distance by using `summary()`. Filtering 0, the minimum distance between two different bus stops, in any case inter-zonal, is 173.8m. Therefore, the maximum intra-zonal distance is 86.9m.

```{r}
distPair %>% 
  filter(dist > 0) %>% 
  summary()

#min(distPair$dist)
#mean(distPair$dist)
#max(distPair$dist)
```
Given the minimum value of `dist`, we will append a constant value of 50m to replace the intra-zonal distance of 0 and rename the columns to origin and destination.

::: {.callout-tip}
## Tip
ifelse(test, yes, no)

Arguments
test - an object which can be coerced to logical mode
yes - return values for true elements of test
no - return values for false elements of test
:::

```{r}
distPair$dist <- ifelse(distPair$dist == 0,
                        50, 
                        distPair$dist)

distPair <- distPair %>% 
  rename(orig = Var1,
         dest = Var2)
summary(distPair)
```
Save to RDS.

```{r}
write_rds(distPair, "data/rds/distPair.rds")
```

## Step 6: Prepare data flow

Compute the total number of passenger trip between and within planning subzones using `group_by()` and `summarise()`. The output shows that there are intra-zonal trips where `ORIGIN_SZ` = `DESTIN_SZ`.

```{r}
od_data <- read_rds("data/rds/od_data.rds")
```

```{r}
flow_data <- od_data %>% 
  group_by(ORIGIN_SZ, DESTIN_SZ) %>% 
  summarise(TRIPS = sum(MORNING_PEAK))
head(flow_data, n = 5)
```

## Step 7: Separate intra-zonal flow from passenger volume df

We will calculate the number of intra-zonal flow where `ORIGIN_SZ` = `DESTIN_SZ`.

```{r}
flow_data$FlowNoIntra <- ifelse(
  flow_data$ORIGIN_SZ == flow_data$DESTIN_SZ, 
  0, 
  flow_data$TRIPS)

flow_data$offset <- ifelse(
  flow_data$ORIGIN_SZ == flow_data$DESTIN_SZ, 
  0.000001, 
  1)

head(flow_data, n = 5)
```

Step 6: Combine the passenger volume data with distance value

We will convert data value type of `ORIGIN_SZ` and `DESTIN_SZ` fields of `flow_data` data frame into factor data type.
`left_join()` of dplyr appends the distance between subzones from `distPair` data frame to `flow_data` data frame.

```{r}
flow_data$ORIGIN_SZ <- as.factor(flow_data$ORIGIN_SZ)
flow_data$DESTIN_SZ <- as.factor(flow_data$DESTIN_SZ)

flow_data1 <- flow_data %>% 
  left_join(distPair,
            by = c("ORIGIN_SZ" = "orig",
                   "DESTIN_SZ" = "dest"))
glimpse(flow_data1)
```

## Step 8: Preparing Origin and Destination Attributes

Based on `PA` and `SZ` of `pop`, we will append the planning subzone codes `SUBZONE_C` from `mpsz`. The output shows that `pop` has a new column `SZ` with subzone codes.

```{r}
pop <- pop %>%
  left_join(mpsz,
            by = c("PA" = "PLN_AREA_N",
                   "SZ" = "SUBZONE_N")) %>%
  select(1:6) %>%
  rename(SZ_NAME = SZ,
         SZ = SUBZONE_C)
glimpse(pop)
```

```{r}
SIM_data <- read_rds("data/rds/SIM_data.rds")
glimpse(SIM_data)
```

# 1.4 Explore data

# 1.5 Plot data

Calibrating Spatial Interaction Models

Visualising the dependent variable

plot the distribution of the dependent variable (i.e. TRIPS) by using histogram

```{r}
ggplot(data = SIM_data, aes(x = TRIPS)) +
  geom_histogram(fill = "pink", color = "black",
                 binwidth = 2500) +
  theme(
    panel.background = element_blank()
  )
```

isualise the relation between the dependent variable and one of the key independent variable in Spatial Interaction Model, namely distance.

```{r}
ggplot(data = SIM_data,
       aes(x = dist,
           y = TRIPS)) +
  geom_point(size = 1, colour = "lightblue") +
  geom_smooth(method = lm) +
  theme(
    panel.background = element_blank()
  )
```

plot the scatter plot by using the log transformed version of both variables, we can see that their relationship is more resemble linear relationship.

```{r}
ggplot(data = SIM_data,
       aes(x = log(dist),
           y = log(TRIPS))) +
  geom_point(size = 1, colour = "lightblue") +
  labs(title = "Trips by Distance") +
  geom_smooth(method = lm) + 
  theme(
    panel.background = element_blank()
  )
```
Checking for variables with zero values

```{r}
summary(SIM_data)
```

replace zero values to 0.99

```{r}
SIM_data$DESTIN_AGE7_12 <- ifelse(
  SIM_data$DESTIN_AGE7_12 == 0,
  0.99, SIM_data$DESTIN_AGE7_12)
SIM_data$DESTIN_AGE13_24 <- ifelse(
  SIM_data$DESTIN_AGE13_24 == 0,
  0.99, SIM_data$DESTIN_AGE13_24)
SIM_data$DESTIN_AGE25_64 <- ifelse(
  SIM_data$DESTIN_AGE25_64 == 0,
  0.99, SIM_data$DESTIN_AGE25_64)
SIM_data$ORIGIN_AGE7_12 <- ifelse(
  SIM_data$ORIGIN_AGE7_12 == 0,
  0.99, SIM_data$ORIGIN_AGE7_12)
SIM_data$ORIGIN_AGE13_24 <- ifelse(
  SIM_data$ORIGIN_AGE13_24 == 0,
  0.99, SIM_data$ORIGIN_AGE13_24)
SIM_data$ORIGIN_AGE25_64 <- ifelse(
  SIM_data$ORIGIN_AGE25_64 == 0,
  0.99, SIM_data$ORIGIN_AGE25_64)

summary(SIM_data)
```


Unconstrained Spatial Interaction Model

```{r}
uncSIM <- glm(formula = TRIPS ~ 
                log(ORIGIN_AGE25_64) + 
                log(DESTIN_AGE25_64) +
                log(dist),
              family = poisson(link = "log"),
              data = SIM_data,
              na.action = na.exclude)
uncSIM
```


R-squared function


```{r}
CalcRSquared <- function(observed,estimated){
  r <- cor(observed,estimated)
  R2 <- r^2
  R2
}
```

compute the R-squared of the unconstrained SIM

```{r}
CalcRSquared(uncSIM$data$TRIPS, uncSIM$fitted.values)
```


```{r}
#r2_mcfadden(uncSIM)
```

Origin (Production) constrained SIM

```{r}
#orcSIM <- glm(formula = TRIPS ~ 
#                 ORIGIN_SZ +
#                 log(DESTIN_AGE25_64) +
#                 log(dist),
#              family = poisson(link = "log"),
#              data = SIM_data,
#              na.action = na.exclude)
#summary(orcSIM)
```

examine how the constraints hold for destinations this time.

```{r}
#CalcRSquared(orcSIM$data$TRIPS, orcSIM$fitted.values)
```

Destination constrained

```{r}
#decSIM <- glm(formula = TRIPS ~ 
#                DESTIN_SZ + 
#                log(ORIGIN_AGE25_64) + 
#                log(dist),
#              family = poisson(link = "log"),
#              data = SIM_data,
#              na.action = na.exclude)
#summary(decSIM)
```


```{r}
#CalcRSquared(decSIM$data$TRIPS, decSIM$fitted.values)
```


Doubly constrained

```{r}
#dbcSIM <- glm(formula = TRIPS ~ 
#                ORIGIN_SZ + 
#                DESTIN_SZ + 
#               log(dist),
#              family = poisson(link = "log"),
#              data = SIM_data,
#              na.action = na.exclude)
#summary(dbcSIM)
```

```{r}
#CalcRSquared(dbcSIM$data$TRIPS, dbcSIM$fitted.values)
```

