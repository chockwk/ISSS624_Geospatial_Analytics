---
title: "2a Spatial Weights and Application"
author: "Wan Kee"
date: "21 November 2023"
date modified: "21 November 2023"
format: html
execute: 
  echo: true
  eval: true
  warning: false
editor: visual
---

# 1.1 Overview

Spatial weights are a fundamental concept in spatial analysis and spatial statistics. They are used to quantify the spatial relationships between geographic locations in a dataset. Spatial weights capture the relation of one location is to another based on their spatial proximity.

There are two types of spatial weights:

::: panel-tabset
## Contiguity Weights

Contiguity-based weights define relationships based on common geographic boundary.

![](/_site/Hands_on_Ex/Hands_on_Ex02/images/Screenshot%202023-11-21%20at%208.52.53%E2%80%AFPM.png){fig-align="center" width="300"}

## Distance-Band Weights

Distance-based weights assign weights based on the Euclidean or other distance measures between locations. Locations closer to each other receive higher weights.

![](/_site/Hands_on_Ex/Hands_on_Ex02/images/Screenshot%202023-11-21%20at%208.58.23%E2%80%AFPM.png){fig-align="center" width="500"}
:::

Learning Objectives:

1.  xx
2.  xx

# 1.2 Load packages

::: {.card .text-white .bg-secondary .mb-3 style="max-width: 40rem;"}
::: card-body
```         
**New package**
`spdep` is comprehensive package for spatial econometrics and spatial 
statistics. It provides the functions and tools for handling spatial 
data, creating spatial weights matrices, and conducting spatial data 
analysis.
```
:::
:::

::: panel-tabset
## Spatial Weights Matrices

`spdep` offers various methods to create spatial weights matrices based on contiguity, distance, and other spatial relationships. Binary or weighted spatial weights matrices are created using functions such as `poly2nb` (polygon-based contiguity), `dnearneigh` (distance-based neighbors), and others.

## Spatial Autocorrelation

`spdep` provides functions to calculate measures of spatial autocorrelation, including global Moran's I, Geary's C, and Getis/Ord G statistics.

## Spatial Regression Models

`spdep` supports various types of spatial regression models, including spatial autoregressive (SAR) models, spatial error models, spatial lag models, and generalized spatial two-stage least squares (GMM-SAR) models.

## Spatial Filtering

`spdep` has functions for spatial filtering, such as Moran eigenvector spatial filtering (MESF) and generalized Moran eigenvector spatial filtering (GMESF), which can be used for spatial smoothing and noise reduction.

## Regional Aggregation

`sdpep` allows for regional aggregation using minimum spanning tree-based methods.
:::

```{r}
pacman::p_load(sf, spdep, tmap, tidyverse, knitr)
```

# 1.3 Import data

::: panel-tabset
## hunan

`hunan` output indicates that the geospatial objects are polygon features. There are 88 features and 7 fields. It is in WGS84 projected coordinates system with XY dimension.

```{r}
hunan = st_read(dsn="data/geospatial", layer="Hunan")
```

## hunan2012

`hunan2012` output indicates 88 features, and 29 fields.

```{r}
hunan2012 = read_csv("data/aspatial/Hunan_2012.csv")
```

## hunan_hunan2012

`left_join()` will merge the selected columns of `hunan` and `hunan2012`.

```{r}
hunan_hunan2012 = left_join(hunan, hunan2012) %>% 
  select(1:4, 7, 15)
head(hunan_hunan2012, n=5)
```
:::

# 1.4 Explore data

# 1.5 Plot data

`GDPPC` is the gross domestic product per capita shows a country's GDP divided by its total population. We will visualise the regional development indicator by plotting a basemap nad a choropleth map with the distribution of GDPPC using `qtm()`.

`qtm()` draws a quick thematic map without arguments or with a search term.

```{r}
basemap <- tm_shape(hunan_hunan2012) +
  tm_polygons() +
  tm_text("NAME_3", size=0.5)

gdppc <- qtm(hunan_hunan2012, "GDPPC")
tmap_arrange(basemap, gdppc, asp=1, ncol=2)
```

# 1.6 Compute and Visualise Contiguity Spatial Weights

`poly2nb()` builds a neighbours list based on regions with contiguous boundaries, that is sharing one or more boundary point.

::: panel-tabset
## Compute QUEEN

![](/_site/Hands_on_Ex/Hands_on_Ex02/images/Screenshot%202023-11-23%20at%201.39.39%E2%80%AFAM.png){width="400"}

Compute Queen contiguity weight matrix:

```{r}
wm_q = poly2nb(hunan_hunan2012, queen = TRUE)
summary(wm_q)
```

The output shows that there are 88 regions in Hunan where the most connected region has 11 neighbours and the two least connected regions have 1 neighbour. The average number of neighbours of the regions is 5.

List the neighbours of the specified polygon in the object:

```{r}
wm_q[[85]]
```

## Compute ROOK

Compute Rook contiguity weight matrix:

```{r}
wm_r <- poly2nb(hunan_hunan2012, queen=FALSE)
summary(wm_r)
```

The output shows that there are 88 regions in Hunan where the most connected region has 10 neighbours and the two least connected regions have 1 neighbour. The average number of neighbours of the regions is 5.

## Create centroids

A connectivity map represents the relationships between geographic units or locations based on spatial proximity or adjacency. It provides a visual representation of how different regions or areas are connected to one another.

`map_dbl()` outputs double vectors, which have numbers that can have decimals. The mapping function applies a given function to each element of a vector and returns a vector of the same length. 

`st_centroid()` is used to extract the centroid coordinates of each polygon feature and returns a point geometry. Note that the centroid is not always inside of the polygon that it is the center of, for example, a “C-shaped” island or a doughnut. `st_point_on_surface()` provides an alternative in which a point within the polygon will be returned.

Step 1: Map the `geometry` column to obtain the `longitude` and `latitude` columns.
Note longitude is the first value in each centroid and latitude is the second value.

```{r}
longitude = map_dbl(hunan_hunan2012$geometry, ~st_centroid(.x)[[1]])
latitude = map_dbl(hunan_hunan2012$geometry, ~st_centroid(.x)[[2]])
```

Step 2: Bind `longitude` and `latitude` into the same object to create `coords`.

`cbind()` merge two data frames, given that the number of rows in both the data frames are equal. `cbind()` can append vectors, matrices, or any data frame by columns. 

```{r}
coords <- cbind(longitude, latitude)
head(coords)
```
## Connectivity Plot

Plot Queen and Rook contiguity based on neighbours map.

```{r}
par(mfrow=c(1,2))
plot(hunan$geometry, main="Queen Contiguity", border="lightgrey")
plot(wm_q, coords, pch = 19, cex = 0.6, add = TRUE, col= "deeppink", main="Queen Contiguity")
plot(hunan$geometry, main="Rook Contiguity", border="lightgrey")
plot(wm_r, coords, pch = 19, cex = 0.6, add = TRUE, col = "purple", main="Rook Contiguity")
```
:::

# 2.7 Compute Distance-band neighbours

**Step 1**: Determine the cut-off distance

`knn2nb()` converts a knn object returned by knearneigh into a neighbours list of class nb with a list of integer vectors containing neighbour region number ids.

`dnearneigh()` identifies neighbours of region points by Euclidean distance in the metric of the points between lower and upper bounds. If unprojected coordinates are used and either specified in the coordinates object x or with x as a two column matrix and longlat=TRUE, great circle distances in km will be calculated assuming the WGS84 reference ellipsoid.

`nbdists()` returns the Euclidean distances along the links in a list of the same form as the neighbours list. If longlat = TRUE, Great Circle distances are used.

```{r}
k1 <- knn2nb(knearneigh(coords))
k1dists <- unlist(nbdists(k1, coords, longlat = TRUE))
summary(k1dists)
```
The output shows that the largest first nearest neighbour distance is 61.79 km, this value as the upper threshold ensures that all objects will have at least one neighbour.

**Step 2:** Compute fixed distance weight matrix

```{r}
wm_d62 <- dnearneigh(coords, 0, 62, longlat = TRUE)
wm_d62
```
The output indicates there are 88 coords and the average number of neighbours is 3.68.

**Step 3:** Plot fixed distance weight matrix

::: panel-tabset

## Combined plot

'k1' indicated in orange lines show the links of 1st nearest neighbours and 'wm_d62' in blue lines show the links of neighbours within the cut-off distance of 62km.

```{r}
plot(hunan_hunan2012$geometry, main="Nearest Distance-band Neighbours", border="lightgrey")
plot(wm_d62, coords, add=TRUE, col="cornflowerblue")
plot(k1, coords, add=TRUE, col="darkorange", length=0.08)
```

## Two Plots

```{r}
par(mfrow=c(1,2))
plot(hunan_hunan2012$geometry, main="1st nearest neighbours", border="lightgrey")
plot(k1, coords, add=TRUE, col="darkorange", length=0.08)
plot(hunan_hunan2012$geometry, main="Distance link", border="lightgrey")
plot(wm_d62, coords, add=TRUE, col="cornflowerblue", pch = 19, cex = 0.6)
```
:::

**Step 4:** Compute adaptive distance weight matrix

One of the characteristics of fixed distance weight matrix is that more densely populated areas tend to have more neighbours than the less dense areas. We can use k-nearest neighbours to restrict the number of neighbours.

::: panel-tabset

## Create 
```{r}
knn8 <- knn2nb(knearneigh(coords, k=8))
knn8
```
The output indicates there are 88 coords and the average number of neighbours is 8.

## Plot

```{r}
plot(hunan_hunan2012$geometry, main="Adaptive distance weight matrix", border="lightgrey")
plot(knn8, coords, pch = 19, cex = 0.6, add = TRUE, col = "darksalmon")
```
:::

# 2.8 Inverse distance weighted interpolation

`nbdists()` is a function returns the Euclidean distances along the links in a list of the same form as the neighbours list. If longlat = TRUE, Great Circle distances are used.

**Step 1:** Compute the distance between areas.

```{r}
dist <- nbdists(wm_q, coords, longlat = TRUE)
ids <- lapply(dist, function(x) 1/(x))
```

**Step 2:** Assign weights to each neighbouring polygon 

Each neighboring polygon will be assigned equal weight (style=“W”). The zero.policy=TRUE option allows for lists of non-neighbors. 

`nb2listw()` function supplements a neighbours list with spatial weights for the chosen coding scheme. 

::: panel-tabset

## Method 1

```{r}
rswm_q <- nb2listw(wm_q, style="W", zero.policy = TRUE)
rswm_q
```
The output shows that n=88 and nn=7744. The weights are assigned equally based on the number of neighbours.

To view the weight of a specific polygon:

```{r}
rswm_q$weights[1]
```
The output shows that object 1 has 5 neighbours with weight 0.2 assigned to each neighbour.

## Method 2

```{r}
rswm_ids <- nb2listw(wm_q, glist=ids, style="B", zero.policy=TRUE)
rswm_ids
```

```{r}
rswm_ids$weights[1]
```
:::

# 2.9 Application of Spatial Weight Matrix

There are four types of spatial lagged variables:

1. Spatial lag with row-standardized weights,
2. Spatial lag as a sum of neighbouring values,
3. Spatial window average, and
4. Spatial window sum.

